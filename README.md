# XMas-Tree-Explosions (X-Mas Tree animation - celebrating New Year's Eve)

## Concept

The idea of this animation is to somewhat combine Christmas and New Year's Eve by showing little colorful explosions on **The Tree**. I already had this idea (or at least a very similar one) last year but I hadn't wanted to fiddle with python as I can code in python but it's not my language of choice. Now that we only have to produce csv-files I can use the tools I excel at and just submit the resulting file.

## The flaw in the GIFT-format (and why that is a good thing, this time around)

Matt mentioned several times in his video that the LEDs could form any kind of shape and although we don't have other shapes to work with right now, flexibility is great. But the format that he defined to store the 3D-positions of each LED-light isn't exactly adapting to the different possible shapes in the same way. Based on the coordinates in the standupmaths Git-repo, all x- and y-coordinates are capped at -1 and 1. As those points in space aren't distributed equally, the y-coordinates in fact never touch these limits at all. In contrast the coordinates that the Harvard-repo offers are less normalized as here the y-coordinates are capped at -1 and 1, while having the x-coordinates scale accordingly, leaving some LEDs at x-coordinates below -1 or above 1. That's not normalized! Because if we switch from a tree-shape to something like a wall-mounted shape (where there is almost no depth/y-variance, the x-coordinates would be all over the place. If we want normalization, we have to define rules that apply to every direction. On that note, having the z-coordinate start at zero is great, but it hasn't got an upper limit. That again is not normalized! It is applicable to this shape but if the GIFT-format should apply to any random shape, we can't make assumption based on the shape we are concerned with today. An actual normalized format would make sure that all three coordinates are capped at -1 and 1 and that the two directions with less variance would be scaled accordingly and probably centered.

Now, as we are talking about a tree-shape this year (again), we can definitely make use of this format, as having all three coordinates normalized adds other issues: If we had a bounded (unit) cube, approximately 50% of the space would feature no LEDs and hence attempting to animate anything in these sparse locations would have no visual outcome. So, although I have to say, that the GIFT-format isn't universal enough to cover all shapes of LED-light-arrangements, it is usable for this exact scenario.

## Applying a second normalization

So, as I said, the format fits our needs, but the given points don't form a cone. Or - to be more precise - the points might, but the format allows other shapes as well, because the coordinate-space forms a quadratic prism and not a cone. Furthermore, there are irregularities as they are human-mounted on the tree. So, what I do first is rearranging the given points to form a cylinder.
The basic idea: Ignore the z-coordinate and project all points onto a plane, then find the smallest circumscribed circle to cover all the points. Based on the center of this cylinder, all the points would be (slightly) shifted compared to the given 0/0/0-origin. But if we ignore that the upper half of the cylinder is mostly empty, we can create almost any patterns in this cylinder and likely hit at least some LEDs. The smaller the bounding shape is the more likely it is to hit something by randomly shooting in the given space.
For a cone-shaped tree a cylinder is a good approximation, but I can only do this, because the shape is fixed in this scenario. If we had another shape to work with, I would have to modify this step! That is the point were I am grateful for the GIFT-format as it perfectly fits the use-case.
Side note: You could also try to find the smallest bounding cone. The problem is that this gets tougher in two ways. First, the base circle will probably be larger then the base circle of my cylinder in order to find the cone with the least volume. Because if you used the smallest circle as its base, the slopes would never meet at one point while still including all LEDs. That is a complex problem to solve. The second issue is that generating (uniformly distributed) random points in a cone means you have to take the different widths at different heights into account. That is probably the easier of the two problems, but I didn't wanted to bother with the first problem and - as you see later - I won't even generate random points in a circle even if this is just as easy as uniformly distributing points in a cone. If you want to do this, go ahead, I prefer easier formulas at the expense of regenerating the data if it doesn't fit my needs.

Now, there are algorithms to find the smallest circumscribed circle, but honestly I was too lazy to bother with them. I rather created a spreadsheet that probably took me longer but was more fun (and likely could be more performant if I wanted to normalize another set of points, it just requires some manual editing). The spreadsheet can perform more than one operation depending on the kind of "defect" in the input data, but most of the time you want to use all in combination.
First, the spreadsheet can do the standard normalization that the GIFT-formatted points should already come in, so, scaling all x- and y-coordinates to `[-1, 1]` and moving the lowest point to `z=0`. But then, the spreadsheet can also find the point(s) with the largest x-y-distance to the z-axes (with some manual help). That lets me rescale the points to form a cylinder with radius 1. Scaled to form a cylinder the points technically are still normalized based on the GIFT-format-definition, no point can exceed the range of -1 to 1 while still being close enough to the z-axes.
But the points likely are also shifted. That results in the situation that the necessary down-scaling is larger then it would have to be. So (with some tweaking of the scaling factor) you can find three points that have the largest distance to the z-axes, input their ids into another sheet and let the spreadsheet determine their center point and shift all points to this new origin. Again, scaling to get a cylinder with radius 1 and my custom tree-specific normalization step is done.
And, it might not be perfect but pretty close to perfect. The necessary down-scaling indeed is lower (1/1.11 instead of 1/1.16). And if I change the last rescaling factor only by a little, there are two points sticking out of the cylinder that are located in two opposing octants (I chose to use octants instead of quadrants to get a better feeling for where the outer most points lie, to be able to select three points for the shifting that are as far apart from each other as possible), indicating that the center should be pretty much dead on.

Alternatively, implement Welzl's algorithm and input the points sorted by their distance to the z-axes (in descending order) to get the most performance, if I got Wikipedia right.
[(source)](https://en.wikipedia.org/wiki/Smallest-circle_problem#Welzl%27s_algorithm)

## Defining the "seed" of my effect

So, the idea of my effect is some form of explosion pattern. At random points in time at random locations in this cylinder an explosion with a random color will take place. Explosions are divided into two phases: At first each explosion will increase in size. Starting with a specific 3D-location (the explosion's "seed", if you will) a sphere of some color will grow over some frames. Then, after the sphere reached its maximum size, the sphere will stay at its position but slowly fade to black again.

To accomplish this I created a spreadsheet that generates a bunch or random numbers and already preprocesses them a little. The spreadsheet generates:
- a random time frame to start an explosion. The animation is split into 100 seeding-frames (the resulting animation will definitely have more than 100 frames, that's just the "frequency" at which explosions can start), several explosions can in theory start in the same frame. You could increase the "resolution" if you either want a longer animation or afterwards shorten the actual animation-speed.
- a random x-coordinate and a random y-coordinate. That means that some points can be outside of the cylinder. I chose to re-calculate the seeds until this doesn't occur (because I don't want to bother with more complex formulas) but you could also just outright ignore any seeds that are outside the cylinder. I would advise against just using them, because that would cause the portions of the tree that point to the corners of the coordinate-system to show more animations than the portions facing the edges and also will have more "incomplete" patterns.
- a random z-coordinate. The z-coordinate clearly has to be scaled to the actual height of the cylinder. That's where an actual normalized format would be beneficial, but as I said, it would cause other issues here and there for this shape. All random coordinates can't lie in the outer 0.2 in each direction. So, x and y are capped at `[-.8, .8]` and z is capped at `[.2, max_height-.2]`. That is done to reduce the number of incomplete patterns further. Still, the cone shape will cause some explosions in the upper (empty) space that will either don't show up at all or only on the very edges of the tree. That's another reason why I chose to re-generate the random values until I got 25 valid entries.
- a random hue. The initial color of each explosion will be at most saturation and value (in HSV-color space) because the fading phase of each explosion will already introduce darker colors. There's no reason to produce almost invisible effects and then let them fade on top of the already dark starting point.
- The spreadsheet then uses those random numbers and the (two times) normalized coordinates to generate intensities for the three base colors and a distance matrix for all coordinates and the generated seed locations. Using this distance matrix (and a visual representation of the time distribution of the seeds) I again regenerate the random values until all explosions touch SOME LEDs and the explosions aren't clustered too much in time.
This is the final output-format of my spreadsheets. That in fact means that the actual code that generates the animation never uses coordinates in the first place. It only uses the distance-matrix and the time- and color-imformation. All the normalization and distance-calculation is done before passing the data to the animator.

## Calculating the actual color-table for the tree

Now, we are at the point were spreadsheets can't help me any further. Because now I have to calculate the color values of each LED and every frame given both of my inputs. And that means to process 500 coordinates and 25 explosion seeds together with temporal and spacial distances and color fading effects. Furthermore, each of the seeding frames will be followed by some number of "evolution-frames" where the animation will undergo a fixed and (for these frames) uninterrupted process of steps to form the wanted animation. But the basic problem is just that LibreOffice only has 1024 columns but you need 1501 for all the color codes for all the 500 LEDs. And LibreOffice in general just don't likes to be used for tables (with formulas) of these sizes.

The problem for generating animation is that I don't really know the update frequency of the new algorithm. Last year's algorithm pretty much ran at some speed mostly defined by the animation's computational load. If you had to compute a lot, the animation would slow down. But this year the RaspberryPi just reads in lines and pushes these numbers out to the lights. The Harvard-code file contains an fps-declaration but the script never actually sleeps for this amount of time, so either someone tested the script and annotated the observed execution-speed or this declaration is deceptive and the script runs at a different speed. To not overshoot, I will work with the assumption of an animation-frequency of 30fps. If the RPi is faster you can always integrate a sleep command (to cover the difference between a 30-th of a second and the time it takes to process one frame), or if it is slower, the animation will just take a bit longer. But given that the Harvard script says "approx. 60fps" at one point, I think the RPi should be capable of 30fps at a minimum.

This will cause the animation to start quite abruptly, but I decided to design the animation as an infinite loop. Each explosion can last long enough for another explosion to already start (ideally I want to have at least three explosions happen at any given point in time, including the ones that are already fading away), so in order to have an infinite loop, right at the start several explosions have to be at different stages in their life-cycle right away.

What happens if two explosions appear close to each other? Well, I have to define this as my seeding doesn't prevent this from happening and we need some deterministic behavior in case this happens. So, as simple as that, we add up all their color values. Obviously capping them at 255. Meaning if a yellow explosion happens near a blue one, we will get some white areas. But that's how light works, so that's totally fine.

Now all we need are a few parameters for the actual algorithm to generate the color-table out of the input files. If we know how long an explosion can last at most, we first duplicate the last few seeds and prepend them to the start of the time scale. That is done to simplify the generation of the individual color-values at the wrapping point were the animation will start back from the beginning. We just start early, compute a few frames while discarding the results, then start actually logging the values but redo the frames that we already calculated in the beginning to get this infinite loop (the first frames can't have any fading patterns, we only get those if there are seeds before that point in time). Then, I want to see the explosions expand for two thirds of a second (meaning 20 frames) and fade over the time of at least 5 seconds (150 frames). The size or an explosion should be .5 in radius. (Yes, that is quite large, but my seeding process warned me of a lot of seeding attempts that didn't show up when using a smaller radius. If I used a more shape-aware random seeding the problem might have been not that severe, but as I can't test the animation myself, I went with the safe way of larger patterns.) The only missing parameter is the number of frames per seeding. If one pattern stays visible for about 6 seconds, and we have one new seed every four seeding frames (on average), and we target three visible explosions all the time, we need a new explosion about every 2 seconds, resulting in one seeding-frame every .5 seconds. Making the whole animation last 1500 frames or 50 seconds (100 potential seedings) if executed at 30fps, resulting in the animation to loop roughly every minute. You could easily make longer animations by adding more seeding-frames with more seeding-events. But that is only a proof-of-concept. And as I don't have such a tree at hand, I guess some of the parameters could make use of further tweaking once I saw the actual animation on the tree.

The actual generating code is rather boring. For each frame, for each LED and for each seeding-event, check the temporal and spacial distance and add some color-component to this light's output if needed. Then, cap each light component at 255 in case this limit is exceeded. Then, print the data into a file and we're done. I could use python, but I chose to use scala because of my greater familiarity with this language. If this project wouldn't require parsing two files to write a third, I would have included a link to an online-editor/-execution tool, but that won't really work here. If you want to tweak the parameters, you have to have scala installed.
